# JVM Memory Structure

```scss
JVM Memory Structure:
â”œâ”€â”€ Method Area
â”œâ”€â”€ Heap
â”œâ”€â”€ Java Stacks (per thread)
â”œâ”€â”€ PC Registers (per thread)
â””â”€â”€ Native Method Stacks (per thread)
```

### 1. Heap (Object Memory):

The heap is where all Java objects live, along with arrays.
Any time you use `new` in Java â†’ memory comes from the heap.

- Shared by all threads
- Managed by the Garbage Collector
- Most performance-critical part of JVM memory

  #### Heap Subdivisions

  Modern JVMs (like HotSpot) divide the heap into generations to optimize GC:

  - 1. Young Generation:
       - Where new objects are allocated
       - Frequently garbage collected (called minor GC)
       - Has 3 regions:
         - Eden space: where objects are first created
         - Survivor spaces (S0, S1): objects that survive minor GC
  - 2. Old (Tenured) Generation:
       - Long-lived objects get moved here
       - Collected less often (major GC or full GC)
       - Larger, but more expensive to clean up

    ```java
    public class User {
        String name;

    }
    User u = new User(); // Allocated in Eden (Young Gen)
    ```

    If u survives several GCs, it gets promoted to Old Gen.

  #### What triggers GC?

  - Heap is filling up
  - An explicit call to `System.gc()` (which JVM may ignore)
  - Allocation failure occurs (e.g., canâ€™t fit object in Eden)

### 2. Java Stack (Per-Thread Memory)

Each thread in a Java program gets its own Java Stack.
It's used for method execution and contains stack frames â€” small memory blocks representing each method call.

When a thread runs:

```css
Thread T1:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Frame: methodC()      â”‚ â† top of the stack (currently executing)
  â”‚ Frame: methodB()      â”‚
  â”‚ Frame: methodA()      â”‚ â† main()
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Each stack frame holds:

1.  Local Variable Array
2.  Operand Stack
3.  Frame Metadata (return address, constant pool reference)

#### 1. Local Variables Array:

- Stores primitive variables and references to objects (not the object itself!)

```java
void sum(int a, int b) {
    int result = a + b;
}
```

`a`, `b`, and `result` go into the local variable array

#### 2. Operand Stack

- Used as a workspace by the bytecode instructions
- Holds temporary values, like operands for arithmetic
- Operates like a real stack: push/pop

```java
int c = a + b;
```

would translate roughly to:

```sql
ILOAD_1      // Push 'a'
ILOAD_2      // Push 'b'
IADD         // Pop 'a' and 'b', add, push result
ISTORE_3     // Pop result into local variable 'c'
```

#### 3. Frame Metadata

- Return address (to know where to go after a method call)
- Constant pool reference (for resolving method/field names)

#### Stack Lifecycle

```java
void foo() {
    int x = 10;
}

void bar() {
    foo();
}

public static void main(String[] args) {
    new Test().bar();
}

```

Execution flow:

1.  JVM starts thread â†’ allocates a new Java Stack
2.  `main()` is called â†’ a stack frame for `main()` is pushed
3.  `bar()` is called â†’ new frame pushed
4.  `foo()` is called â†’ new frame pushed
5.  When `foo()` returns â†’ its frame is popped
6.  Same for `bar()` and `main()`

```java
void example() {
    int x = 5;                // Primitive on stack
    String s = "hi";          // 's' (reference) on stack
                              // String object â†’ heap
}
```

#### How does it all connect?

```java
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   .java file â”‚ â”€â”€â”€â”€â–¶ â”‚  .class file â”‚ â”€â”€â”€â”€â–¶ â”‚     JVM      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚              â”‚
                                              â”‚              â”‚
                                              â–¼
                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                               â”‚ Class Loader Subsystem     â”‚
                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                             â”‚
                                             â–¼
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚ Memory Setup (Stack, Heap, etc.)     â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                             â”‚
                                             â–¼
                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                           â”‚ Execution Engine                â”‚
                           â”‚   â”œâ”€ Interpreter                â”‚
                           â”‚   â””â”€ JIT Compiler (hot code)    â”‚
                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                             â”‚
                                             â–¼
                               JVM Executes Your Code ğŸš€
```

### 3. Program Counter Register (PC Register)

The Program Counter (PC) Register is a tiny memory cell assigned to each thread, and its job is simple but vital:
**It holds the address (offset) of the next bytecode instruction the current thread should execute.**

### 4. Native Method Stack (per-thread)

While the Java Stack holds frames for Java methods, the Native Method Stack holds frames for native (non-Java) methods that are invoked via JNI.

What Happens Internally?

1.  JVM thread is executing Java code â†’ Java Stack in use
2.  A native method is invoked via JNI:

```java
System.gc(); // Native method
```

3. JVM jumps to native code (C/C++)
4. That native method uses the Native Stack to:
   - Store parameters
   - Store return addresses
   - Handle native recursion
